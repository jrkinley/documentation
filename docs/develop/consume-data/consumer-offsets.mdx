---
title: Consumer Offsets
---

<head>
    <meta name="title" content="Consumer Offsets | Redpanda Docs"/>
    <meta name="description" content="Learn about consumer offsets, the position of each consumer's last read record, and how Redpanda brokers support them."/>
    <link rel="canonical" href="https://docs.redpanda.com/docs/develop/consume-data/consumer-offsets/" />
</head>

Learn about consumer offsets&mdash;the position of each consumer's last read record&mdash;and how Redpanda brokers support them.

## About consumer offsets

A consumer reads records from a partition sequentially, and the offset of the last record read from a partition by a consumer is the _consumer offset_. A consumer registers its consumer offset with a broker by making a _commit request_ to the broker. A consumer's commit request can be synchronous or asynchronous, and it can be done manually by an application or automatically at a configurable interval. The consumer offset that a new consumer starts with can be configured to be the earliest or latest available offset of a partition (or throw an exception if no offset is available).

Redpanda saves the committed consumer offsets in an internal, compacted topic named `__consumer_offsets` that tracks the consumer offsets of each partition per group. In the event of a group rebalancing or a consumer crash or restart, a member consumer gets the offset of the next unread record from the group [coordinator](../consumer-groups), who in turn gets it from `__consumer_offsets`.

A group coordinator sends a successful offset commit response to the consumer only after all the replicas of the `__consumer_offsets` topic receive the offsets. In case the offsets fail to replicate within a configurable timeout, the offset commit will fail and the consumer may retry the commit after backing off. 

The brokers periodically compact the offsets topic because it only needs to maintain the most recent offset commit per partition. 
The coordinator also caches the offsets in an in-memory table to serve offset fetches quickly.

### Consumer lag

When the rate of record production is faster than the rate of record consumption, the latest offset in a partition can grow larger than the current (largest) offset processed by a consumer. A consumer can also keep up with producers, but its rate of committal can be irregular. The _consumer lag_ is the difference between a partition's latest offset and a consumer's current offset. An increasing consumer lag can be an indicator of a consumer slowing down for a problematic reason, including low system resources and high network latency.

## Configuring consumer offsets

You can configure a consumer to manage offset committal either automatically or manually. You can also implement a consumer to commit offsets either synchronously or asynchronously.

### Automatic offset management

To enable automatic offset management, a consumer sets the [`enable.auto.commit`](../consumer-properties#enableautocommit) consumer property to `true`. With it enabled, a consumer automatically commits offsets with a broker at a period configured by the `auto.commit.interval.ms` consumer property.

When a group is initialized and there is not yet any committed offsets for its members, the [`auto.offset.reset`](../consumer-properties#autooffsetreset) consumer property defines how to either automatically set (reset) the initial offset to the earliest or latest offset of the partition, or to a manually specified offset.   

### Manual offset management

To commit consumer offsets manually, a consumer sets the [`enable.auto.commit`](../consumer-properties#enableautocommit) consumer property to `false`, then it calls a commit method of the Kafka Consumer API to commit one or more offsets.

The available commit methods allow for committing all offsets that were retrieved by the last call to poll or to commit the offsets specified in a method parameter (a map of offsets). 

The commit methods also enable synchronous or asynchronous committal:
- A synchronous commit blocks until the commit succeeds or fails.
- An asynchronous commit doesn't block, and errors are passed to a callback handler.
